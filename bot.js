console.log(`
  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù 
  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù     
  `);

  console.log(`
    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó     
    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     
    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     
    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     
    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `);
    console.log(`****Created by Hardeep****`);  
    
const puppeteer = require('puppeteer');
const fs = require('fs');
const MAGICNEWTON_URL = "https://www.magicnewton.com/portal/rewards";
const DEFAULT_SLEEP_TIME = 24 * 60 * 60 * 1000; // 24 hours
const RANDOM_EXTRA_DELAY = () => Math.floor(Math.random() * (60 - 20 + 1) + 20) * 60 * 1000; // 20-60 mins random delay

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function parseTimeString(timeStr) {
  const parts = timeStr.split(':').map(Number);
  if (parts.length !== 3) return null;
  return {
    hours: parts[0],
    minutes: parts[1],
    seconds: parts[2],
    totalMs: (parts[0] * 3600 + parts[1] * 60 + parts[2]) * 1000
  };
}

async function showLiveCountdown(totalMs) {
  while (totalMs > 0) {
    const hours = Math.floor(totalMs / (1000 * 60 * 60));
    const minutes = Math.floor((totalMs % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((totalMs % (1000 * 60)) / 1000);
    console.log(`‚è≥ Next roll available in: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')} `);
    await delay(1000);
    totalMs -= 1000;
  }
  console.log("\n‚úÖ Time reached! Retrying roll...");
}

(async () => {
  console.log("üöÄ Starting Puppeteer Bot...");

  while (true) {
    try {
      console.clear();
      console.log("üîÑ New cycle started...");
      const browser = await puppeteer.launch({ headless: true, args: ['--no-sandbox', '--disable-setuid-sandbox'] });
      const page = await browser.newPage();

      if (fs.existsSync('cookies.json')) {
        const cookies = JSON.parse(fs.readFileSync('cookies.json'));
        await page.setCookie(...cookies);
        console.log("‚úÖ Cookies loaded successfully. \n‚è≥ Webpage Loading: may take up to 60 secs...");
      } else {
        console.log("‚ùå Cookies file not found. Please run the login step first.");
        await browser.close();
        return;
      }

      await page.goto(MAGICNEWTON_URL, { waitUntil: 'networkidle2', timeout: 60000 });
      console.log("üåê Page loaded.");

      const userEmail = await page.$eval('p.gGRRlH.WrOCw.AEdnq.hGQgmY.jdmPpC', el => el.innerText).catch(() => 'Unknown');
      console.log(`üìß Logged in as: ${userEmail}`);

      let userCredits = await page.$eval('#creditBalance', el => el.innerText).catch(() => 'Unknown');
      console.log(`üí∞ Current Credits: ${userCredits}`);

      await page.waitForSelector('button', { timeout: 30000 });
      const rollNowClicked = await page.$$eval('button', buttons => {
        const target = buttons.find(btn => btn.innerText && btn.innerText.includes("Roll now"));
        if (target) {
          target.click();
          return true;
        }
        return false;
      });

      if (rollNowClicked) {
        console.log("‚úÖ 'Roll now' button clicked!");
      }
      await delay(5000);

      const letsRollClicked = await page.$$eval('button', buttons => {
        const target = buttons.find(btn => btn.innerText && btn.innerText.includes("Let's roll"));
        if (target) {
          target.click();
          return true;
        }
        return false;
      });

      if (letsRollClicked) {
        console.log("‚úÖ 'Let's roll' button clicked!");
        await delay(5000);
        const throwDiceClicked = await page.$$eval('button', buttons => {
          const target = buttons.find(btn => btn.innerText && btn.innerText.includes("Throw Dice"));
          if (target) {
            target.click();
            return true;
          }
          return false;
        });

        if (throwDiceClicked) {
          console.log("‚úÖ 'Throw Dice' button clicked!");
          console.log("‚è≥ Waiting 20 seconds for dice animation...");
          await delay(20000);
          userCredits = await page.$eval('#creditBalance', el => el.innerText).catch(() => 'Unknown');
          console.log(`üí∞ Updated Credits: ${userCredits}`);
        } else {
          console.log("‚ö†Ô∏è 'Throw Dice' button not found.");
        }
      } else {
        console.log("üëá Wait! ROLL not available yet. ");
        const timerText = await page.evaluate(() => {
          const h2Elements = Array.from(document.querySelectorAll('h2'));
          for (let h2 of h2Elements) {
            const text = h2.innerText.trim();
            if (/^\d{2}:\d{2}:\d{2}$/.test(text)) {
              return text;
            }
          }
          return null;
        });

        if (timerText) {
          console.log(`‚è± Time Left until next ROLL: ${timerText}`);
          const timeData = parseTimeString(timerText);
          if (timeData) {
            await showLiveCountdown(timeData.totalMs + 5000);
          } else {
            console.log("‚ö†Ô∏è Failed to parse timer. Using default sleep time.");
          }
        } else {
          console.log("‚ö†Ô∏è No timer found. Using default sleep time.");
        }
      }
      await browser.close();

      const extraDelay = RANDOM_EXTRA_DELAY();
      console.log(`üîÑ Cycle complete. Sleeping for 24 hours + random delay of ${extraDelay / 60000} minutes...`);
      await delay(DEFAULT_SLEEP_TIME + extraDelay);
    } catch (error) {
      console.error("‚ùå Error:", error);
    }
  }
})();
